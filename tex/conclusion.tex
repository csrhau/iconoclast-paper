\section{Conclusion}
\label{sec:conclusion}
\noindent
This paper presents POSE, a visual model which captures the energy/runtime optimisation trade-off space of a code.
POSE is a robust analytical model which provides developers with quantitative and actionable insights.
The main use case for POSE is helping to determine whether power or runtime optimisation is the best approach for improving the efficiency of a code.

POSE works by partitioning the energy/runtime plane into areas corresponding to runtime and power optimised versions of an initial code with respect to a cost metric.
We provide derivations of POSE's boundaries for the Energy Delay Squared family of metrics.
We also demonstrate how to apply POSE in practice by modelling the CPU power consumption of a number of codes taken from the Rodinia and Mantevo benchmark suites.  

The results in this paper illustrate that runtime optimisation is the preferred approach to reducing the energy consumption of MiniMD and to a lesser extent LavaMD.
Our investigation into frequency scaling also highlights the ability of POSE to rule out dominated configurations and hence reduce the optimisation search space.
We believe that both results are of interest to performance engineers and serve to demonstrate the practical utility of POSE.

\subsection*{Future Work}
\noindent
Future work will further validate POSE by applying it to a broader selection of scientific codes running on a range of machines.
The quantitative nature of our technique makes it particularly well suited to comparison studies.
As such, we are particularly keen to investigate the power optimisation opportunities presented by different architectures.

Our ultimate aim is to demonstrate how POSE may be used to identify specific optimisations.
This will involve developing feasible performance envelopes for individual subsystems including memory, file systems and processors. 
We also intend to profile specific classes of code and establish $P_{min}$ baselines for each.
Doing so would allow POSE to highlight optimisation opportunities at a per-kernel, per-subsystem level and hence facilitate targeted optimisation.
