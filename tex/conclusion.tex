\section{Conclusion}
\label{sec:conclusion}
\noindent
This paper presents POSE, a mathematical and visual model which captures the trade off between software power consumption and runtime.
POSE provides insights regarding the scope a code has for power optimisation as well as the level of improvement which can be expected.
These insights help developers to determine whether power or runtime optimisation is the best approach for improving the efficiency of a code.

POSE works by partitioning the energy/runtime plane into areas corresponding to runtime and power optimised versions of an initial code with respect to an optimisation metric.
We provide derivations of POSE's boundaries for the Energy Delay Product family of metrics.
We also discuss the various insights our model provides.

We demonstrate POSE by modelling the CPU power consumption of a number of codes taken from the Rodinia and Mantevo benchmark suites.  
Our results illustrate that runtime optimisation is the preferred approach to reducing the energy consumption of MiniMD, whilst LavaMD shows some scope for power optimisation.
Our investigation into frequency scaling also highlights the ability of POSE to rule out dominated configurations and hence reduce the optimisation search space.
We believe these results are of interest to performance engineers and serve to demonstrate the practical utility of POSE.

POSE is under consideration for inclusion into a state of the art application analytics for HPC clusters and applications \textit{[paragraph redacted to preserve anonymity]}.

\subsection*{Future Work}
\noindent
Future work will further validate POSE by applying it to a broader selection of scientific codes running on a range of machines.
The quantitative nature of our technique makes it particularly well suited to comparison studies.
As such, we are particularly keen to investigate the power optimisation opportunities presented by different architectures.

Our ultimate aim is to demonstrate how POSE may be used to identify specific optimisations.
This will involve developing feasible performance envelopes for individual subsystems including memory, file systems and processors. 
We also intend to profile specific classes of code and establish $P_{min}$ baselines for each.
Doing so would allow POSE to highlight optimisation opportunities at a per-kernel, per-subsystem level and hence facilitate targeted optimisation.
