\section{Conclusion}
\label{sec:conclusion}
This paper presents POSE, a visual heuristic to describe the energy consumption characteristics of a code.
POSE is a robust analytical model capable of providing developers with quantitative and actionable insights.
The main use case for POSE is to help performance engineers determine whether power or runtime optimisation is the best approach to take when improving the energy efficiency of a code.

We demonstrate POSE with an investigation into CPU power consumption.
\todo{Summary of approach}

Construction of a feasible performance envelope is amounts to selecting control and dependent variables from the $(S, A, C)$ parameters.
\todo{The graphs and tables of results within this section were produced automatically.}

The figures produced by POSE are all upper bounds, and the benefits of power optimisation will be more modest in practice. Even so, these figures are useful as they allow performance engineers to make informed decisions about where best to focus their efforts. If they consider a $1.03 \times$ speed up to be more achievable than up to the maximum $1.17\times$ reduction in activity factor then they can proceed to apply conventional optimisations safe in the knowledge that overall performance will improve despite any increases in activity factor.

If a performance engineer decides the benefits of power optimisation are worth pursuing after applying POSE, the question still remains as to how they should go about searching for those optimisations.

The results in this paper illustrate that runtime optimisation is the preferred approach to reducing the energy consumption of MiniMD and to a lesser extent LavaMD.
Our investigation into frequency scaling also highlights the ability of POSE to rule out dominated configurations and hence reduce the optimisation search space.
We believe that both results are of interest to performance engineers and demonstrate the practical utility of POSE.

\subsection{Future Work}
Future work will further validate POSE by applying it to a broader selection of scientific codes running on a range of machines.
The quantitative nature of our technique makes it particularly well suited to comparison studies.
As such, we are particularly keen to investigate the power optimisation opportunities presented by different architectures.

Our ultimate aim is to demonstrate how POSE may be used to identify specific optimisations.
This will involve developing feasible performance envelopes for individual subsystems including memory, file systems and processors. 
We also intend to profile specific classes of code and establish $P_{min}$ baselines for each.
Doing so would allow POSE to highlight optimisation opportunities at a per-kernel, per-subsystem level and hence facilitate targeted optimisation.
