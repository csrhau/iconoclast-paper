\section{Investigation}
\label{sec:investigation}


We demonstrate the utility of POSE with an investigation into the CPU power consumption characteristics of several popular benchmarks.
Our findings allow us to identify those codes which have most to gain from power optimization, and to quantify any potential benefits.

The first stage to applying POSE in practice is to gain an understanding of the target platform in order to derive appropriate values for the maximum and minimum power consumption.
While it would be valid to simply rely on manufacturer published limits, these are typically estimates and tend to be overly conservative.
POSE works best when the maximum and minimum power bounds are as tight as possible, and so we rely on measurements rather than estimates.

Current state-of-the-art processors are based on Complimentary Metal Oxide Semiconductor (CMOS) technology and multi- and many-core super-scalar architectures.
The limits of these technologies are fast approaching and research into the next generation of power-efficient architectures and semiconductor fabrication techniques is under way \cite{esmaeilzadeh:2011aa}.

The power draw of CMOS chips can be separated into components as described by \autoref{eq:totpwr}, of which dynamic and leakage power are the most significant.
Dynamic power refers to power consumed as logic gates change state while a processor performs work. 
Leakage power stems from the fact that at very small scales the insulating properties of silicon break down, allowing some current to leak out even when gates remain inactive.
Other forms of power dissipation exist, however their effects are relatively minor \cite{kaxiras:2008aa}.


\begin{equation}
\label{eq:totpwr}
P_{tot} = P_{dyn} + P_{leak} + P_{other}
\end{equation}
\begin{equation} 
\label{eq:dynpwr}
P_{dyn} \propto CV^{2}Af
\end{equation}

\autoref{eq:dynpwr} is a common approximation for dynamic power in which C denotes load capacitance, $V$ the supply voltage, $A$ the activity factor and $f$ the clock frequency.
Of these, only activity factor is directly related to processor workload as it captures the percentage of logic elements which change state each clock cycle.
Conversely, capacitance is a fixed value arising from the wire lengths of on-chip structures.


Historically, dynamic power has been the biggest contributor to $P_{tot}$, however leakage power has been on track to overtake it since the breakdown of Dennard Scaling.  Sub-threshold and gate-oxide leakage dominate total leakage current, and they both increase exponentially as transistors shrink. Process improvements like the introduction of high-k dielectric materials~\cite{jan:2009aa} have kept leakage power in check over the last decade, however there is no avoiding the fact that insulating properties will degrade as transistors get smaller.

\todo{De-yoda, state these effect power}
Processor frequency and supply voltage may also be influenced by workload through the actions of Dynamic Voltage and Frequency Scaling (DVFS) activity.
These properties vary in tandem, taking on predetermined values dependent on a hardware-specific number of fixed P-States.
To paraphrase, DVFS can act to reduce the clock speed of underutilized processors. When this happens, voltage requirements also decrease.

An important feature of the equations governing power draw is that only $P_{dyn}$ is directly influenced by software, in particular due to its inclusion of the $A$ term. Software can also indirectly effect both dynamic and leakage current if it triggers changes to clock frequency and therefore supply voltage through DVFS. \todo{Ensure define dvfs} \todo{reword this bit - no equations now}

The two factors a performance engineer may influence which contribute to power consumption are activity factor and P-State.
To construct our $P_min$ and $P_max$ we must be able to effectively control these factors.
In order to do this, we have devised the following benchmark.


\todo{consider each in turn as a potential source of optimizations.}

\begin{table}
\centering
\input{tab/tex/power_of_cores_x_freq.tex}
\caption{Baseline CPU Power (W)}
\end{table} 


%TODO make sure this is explicitly Linpack table in text
\begin{table}
\centering
\input{tab/tex/linpack_costs.tex}
\caption{Roofline CPU Power (W)}
\end{table} 

\begin{figure}
\centering
\input{plot/minimd-investigation/plot_core}
\caption{MiniMD $Et^2$ POSE for Activity Factor Optimization}
\label{fig:minimd}
\end{figure}


\begin{figure}
\centering
\input{plot/lavamd-investigation/plot_core}
\caption{LavaMD $Et^2$ POSE for Activity Factor Optimization}
\label{fig:lavamd}
\end{figure}

\begin{table}
\centering
\input{tab/tex/minimd_pose}
\caption{miniMD POSE insights, 4 cores at 3.2 GHz}
\end{table} 


\begin{figure}
\centering
\input{plot/minimd-pstates/plot_core}
\caption{MiniMD $Et^2$ POSE for P-State Optimization}
\label{fig:minimd-pstates}
\end{figure}


\begin{figure}[ht]                                                               
\centering                                                                      
\lstset{basicstyle=\ttfamily\footnotesize\bfseries, frame=tb} %small bold text, lines top and bottom 
\lstinputlisting[]{lst/alpha_benchmark.c}              
\caption{Baseline Power Micro-Benchmark}                            
\label{fig:microbench}                                                           
\end{figure}  



\begin{table}
\centering
\input{tab/tex/code_metrics}
\caption{\todo{redo}, 4 cores at 3.2 GHz}
\end{table} 


We first formalize the notion of maximum and minimum power by defining the range of values that activity factor can take whilst running a code in a given P-state as $[\alpha  .. \beta]$ where $0 < \alpha < \beta < 1$, and their associated power draws as $P_{\alpha}$ and $P_{\beta}$ respectively, with $P_{\alpha} < P_{\beta}$. \todo{Point out in other (multi-system) domains the approach is still valid, we just need a sensible max and min.}


We approximate $P_{\alpha}$ by monitoring the power consumed whilst running an appropriate baseline benchmark. This code performs the minimum amount of work possible whilst keeping the system active. In particular, we wish to minimize our activity factor whilst matching the clock frequency and voltage figures we expect to see when code is running. We cannot simply halt the CPU because this would also stop many of the background tasks which contribute to $P_{\alpha}$.

Although a chip performing no work may use a very small amount of power, no amount of optimization will yield the same level of efficiency.

\todo{for tighter bounds, proxy application could be developed}

We employ the code given in \autoref{fig:microbench} to derive our baseline.  It consists of a single instruction, performs no computation and places no demand on the memory subsystems. Any non-trivial computation will have a higher activity factor than this minimal micro-benchmark. If the application to be optimized blocks on IO this can be incorporated by measuring the power consumed when the CPU is inactive and adjusting $P_\alpha$ proportionately. We defer measurement of $P_{\beta}$ for now as its precise value is not relevant to the current discussion. 



\todo{As there are two factors which control CPU power consumption we will consider each seperately. }
