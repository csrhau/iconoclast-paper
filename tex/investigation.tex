\section{Investigation}
\label{sec:investigation}
We now use POSE to investigate the CPU power consumption of codes from the Mantevo~\cite{heroux:2009aa} and Rodinia~\cite{che:2009aa} benchmark suites.
The applications studied are simplified versions of production codes intended for research purposes.
As such they have relatively compact code bases and well understood behaviours while still providing represantative workloads.

CPU energy consumption accounts for a significant portion of the energy used by high performance systems~\cite{rong:2010aa} and is therefore a prime target for optimisation.
It can also be measured accurately on comodity hardware~\cite{hackenberg:2013aa} making it a suitable candidate for POSE modelling.

\subsection{CPU Power Consumption}
\label{ssec:cpupower}
Current processors are based on Complimentary Metal Oxide Semiconductor (CMOS) technology.
\autoref{eq:totpwr} separates the power draw of CMOS chips into its component parts, of which dynamic and leakage power are the most significant.
\begin{equation}
\label{eq:totpwr}
P_{tot} = P_{dyn} + P_{leak} + P_{other}
\end{equation}
Dynamic power is consumed when logic gates change state.
Leakage power exists because at microscopic scales the insulating properties of silicon break down, allowing some current to escape even when gates remain inactive.
Other forms of power dissipation exist, however their effects are relatively minor \cite{kaxiras:2008aa}.
\begin{gather}
P_{dyn} \propto CV^{2}Af \label{eq:dynpwr} \\
P_{leak} = V\times I_{leak} \label{eq:staticpwr}
\end{gather}
\autoref{eq:dynpwr} is a common approximation for dynamic power in which $C$ denotes load capacitance, $V$ the supply voltage, $A$ the activity factor and $f$ the clock frequency.
\autoref{eq:staticpwr} is a simplified expression for leakage power which exploits the fact that leakage current ($I_{leak}$) is invariant to processor workload~\cite{kim:2003aa}.

Activity factor captures the fraction of logic elements which change state each clock cycle.
Frequency and supply voltage vary in tandem, taking values from a set of $(frequency, voltage)$ pairs known as P-states.
Dynamic Voltage and Frequency Scaling (DVFS) selects a P-state based on workload, or places the CPU into an energy saving mode if no work is available.
Finally, capacitance and leakage current are constants dictated by hardware design.

Processor architecture also plays a significant roll in determining total power consumption.
Each core in a multicore architecture operates independantly with its own activity factor and in some cases P-state.
As a result, \autoref{eq:totpwr} should be summed across all cores to arrive at a value for the entire processor.

\subsection{Feasible Performance Envelope}
The first step in applying POSE is to construct a feasible performance envelope.
Many manufacturers publish power dissipation figures for their hardware, however for safety reasons these are usually conservative estimates.
POSE works best when the maximum and minimum power bounds are as tight as possible, therefore we determine $P_{\max}$ and $P_{\min}$ empirically.

We specify power benchmarks using $(S,A,C)$ tuples, with P-state $S$, activity factor $A$ and active core count $C$.
Our $P_{min}$ and $P_{max}$ benchmarks should reflect the range of values these properties can take for a given code $\theta$.
This notion is formalised by \autoref{eq:pbench}.
\begin{align}
  \label{eq:pbench}
  \begin{split}
    P_{min} &= (S_{min}, A_{min}, C_{min}~\vert~\theta), \\
    P_{max} &= (S_{max}, A_{max}, C_{max}~\vert~\theta) 
  \end{split}
\end{align}
The values of $S$, $A$, and $C$ depend on the code and the nature of the optimisations being considered.
POSE models for inherently serial codes should be constructed using single threaded benchmarks where $C_{min} = C_{max} = 1$, for example.

The \texttt{cpufrequtils} package allows us to override DVFS and manually set the desired P-state $S$.
We control the number of active cores $C$ by specifying the number of threads used by our benchmarking routines and pinning each one to its own core to prevent migration.
The remaining property is activity factor, which is influenced by benchmark code.

\begin{figure}[ht]
\centering
\lstset{basicstyle=\ttfamily\footnotesize\bfseries, frame=tb} %small bold text, lines top and bottom
\lstinputlisting[]{lst/alpha_benchmark.c}
\caption{Activity Factor $\alpha$ Benchmark Code}
\label{fig:microbench}
\end{figure}

We define the range of values that $A$ can take for some fixed $S$ and $C$ as $[\alpha,~\beta]$ where $0 < \alpha < \beta < 1$.
Our code for targeting activity factor $\alpha$ is given in \autoref{fig:microbench}.
This benchmark executes a single \texttt{jmp} instruction each clock cycle, preventing instruction pipelining.
It performs no floating point or integer calculations and no memory accesses whilst keeping control logic to a minimum.

Non-trivial codes perform more work per unit time than our minimal benchmark.
This additional work means more transistors changing state per cycle, and hence a higher activity factor.
The only exception occurs when applications are blocked for long periods, allowing the processor to enter an idle state.
This can be addressed by adding delays to the benchmark if necessary.

FIRESTARTER~\cite{hackenberg:2013ab} serves as our benchmark for activity factor $\beta$.
This tool is designed to trigger near-peak power consumption across a range of x86\_64 processors.
It consists of hand optimised assembly routines which raise activity factor above the level achievable with high level languages.
Prime95 and Linpack were also evaluated as potential $\beta$ benchmarks however they were consistently outperformed by FIRESTARTER.

The benchmark parameter space is small enough to fully characterise a processor by measuring all $(S,A,C)$ configurations.
Benchmarking runs lasted for 120 seconds to allow enough time for power readings to stabilise.
We extended the Unix \texttt{time} binary to gather power consumption figures using Intel's Running Average Power Limit (RAPL) technology~\cite{david:2010aa}.
The techniques described in \cite{hahnel:2012aa} were used to promote measurement accuracy.
Results are presented in \autoref{tab:fpe_params}, which identifies P-states by their frequency component.

\begin{table}
\centering
\caption{Feasible Performance Envelope Parameters (W)}
\label{tab:fpe_params}
\input{tab/tex/fpe_params.tex}
\end{table}

\subsection{POSE Models for Code Optimisation}
Having characterised our system we now proceed to build POSE models for applications in the Mantevo and Rodinia suites.
These codes were compiled with ICC version 14.0.0.
Codes were run with default configurations where available.
The energy and runtime costs associated with each code is given in \autoref{tab:code_metrics}.

\begin{table}
\centering
\caption{Code Metrics for $S = 3.2\text{ GHz}$, $C = 4$}
\label{tab:code_metrics}
\input{tab/tex/code_metrics.tex}
\end{table}

All codes ran in parallel across four cores.
They also spent a negligible amount of time waiting for resources. 
This allowed the CPU to run at its maximum supported frequency of 3.2 GHz.
For the first stage of this investigation we disregard optimisations which reduce parallelism ($C < 4$) or processor throughput ($S < 3.2GHz$).
The benchmark configurations used were $(\text{3.2 GHz}, \alpha, 4)$ for $P_{min}$ and $(\text{3.2 GHz}, \beta, 4)$ for $P_{max}$, yielding power draws of 26.88W and 49.61W respectively.

\begin{table}
  \setlength{\tabcolsep}{.5em}
  \caption{$E^1t^2$ POSE Points}
  \begin{subtable}{\textwidth}
  \centering
  \caption{Time (s)}
  \input{tab/tex/code_pose_time.tex}
  \end{subtable}
  \begin{subtable}{\textwidth}
  \centering
  \caption{Energy (J)}
  \input{tab/tex/code_pose_energy.tex}
  \end{subtable}
  \label{tab:pose_params}
\end{table}

\autoref{tab:pose_params} summarises the POSE models constructed for each code.
The remainder of this section focusses on MiniMD and LavaMD as the two codes representing the extremes of power consumption.
POSE models for these two codes are reproduced graphically in \autoref{fig:minimd_pose} and \autoref{fig:lavamd_pose}.
When comparing these diagrams it is readily apparent that LavaMD offers far more scope for power optimisation than MiniMD, which offers virtually none. 
POSE provides the following insights for LavaMD:
\begin{itemize}
  \item At most 353.36J can be saved by reducing power consumption
  \item The maximum slowdown from energy optimisation is 4.12s
  \item The most power optimised value of $E^1t^2$ is 6332609, a 30.59\% reduction
  \item A speed up of 8.77s, or 1.15x, strictly outperforms $\theta$
  \item A speed up of 15.29s, or 1.30x, strictly outperforms any power optimisation
\end{itemize}

\begin{figure}[t]%
  \providecommand{\plotwidth}{.95\linewidth}
  \begin{subfigure}[t]{.5\linewidth}%
    \input{plot/minimd-investigation/plot_core}%
    \caption{MiniMD}%
    \label{fig:minimd_pose}
  \end{subfigure}%
  \begin{subfigure}[t]{.5\linewidth}%
    \input{plot/lavamd-investigation/plot_core}%
    \caption{LavaMD}%
    \label{fig:lavamd_pose}
  \end{subfigure}%
  \begin{center}%
    \ref{minimd:legend}%
  \end{center}%
  \caption{$E^1t^2$ POSE comparrison}%
  \label{fig:comparrison}%
\end{figure}


\subsection{POSE Models for Frequency Scaling}
The relationship between P-state and performance is non-linear and dependent on workload.
Operating at lower power P-states can significantly increase runtime, offsetting some or all of the potential energy savings.

In general, applications for which external bottlenecks like 

In general, P-states with unning a processor 


DVFS selects the P-state which offers the best energy/runtime trade-off for the current workload.
This reactive approach is sub-optimal for dynamic workloads.
Proactive, application-aware scaling can save energy in these cases~\cite{choi:2004aa}.
We show how POSE can be used to reason about this class of optimisation.

For this demonstration we suppose that optimisations can arbitrarily impact P-state as well as activity factor.
This corresponds to the feasible performance envelope given in \autoref{eq:pbfreq}.

\begin{align}
  \label{eq:pbfreq}
  \begin{split}
    P_{min} &= (1.6\text{ GHz}, \alpha, 4) = 13.51W, \\
    P_{max} &= (3.2\text{ GHz}, \beta, 4) = 49.61W
  \end{split}
\end{align}

We begin by plotting the POSE models for our unmodified code running under the control of DVFS. 

\begin{figure}[t]%
\begin{subfigure}[t]{.5\linewidth}%
\centering%
\input{plot/minimd-pstates/plot_core}%
\caption{MiniMD}%
\end{subfigure}%
\begin{subfigure}[t]{.5\linewidth}%
\input{plot/lavamd-pstates/plot_core}%
\caption{LavaMD}%
\end{subfigure}%
\begin{center}%
\ref{minimd-pstate:legend}%
\end{center}%
\caption{$E^1t^2$ POSE for P-state Optimisation}%
\label{fig:pstates}%
\end{figure}%

It is trivial to perform the same kind of investigation for optimisations which impact core counts.

\todo{Not actually scaling individual kernels}

