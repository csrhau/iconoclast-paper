\section{Investigation}
\label{sec:investigation}
We now use POSE to investigate the CPU power consumption of codes from the Mantevo~\cite{heroux:2009aa} and Rodinia~\cite{che:2009aa} suites.
The applications we study are simplified versions of production codes intended for research purposes.
As such they exhibit relatively compact code bases and well understood behaviours while still providing represantative workloads.

CPU energy consumption accounts for a significant portion of the energy used by high performance systems~\cite{rong:2010aa}, making this a prime candidate for optimisation.
Crucially for POSE, this variety of power consumption can be accurately measured on unmodified comodity hardware~\cite{hackenberg:2013aa}.

CPU energy consumption was measured using Intel's Running Average Power Limit (RAPL) technology~\cite{david:2010aa}.
We created a tool based on the Unix \texttt{time} to output energy consumption figures as well as conventional runtime figures.
The techniques described in \cite{hahnel:2012aa} were used to ensure measurement accuracy.


\subsection{CPU Power Consumption}
\label{ssec:cpupower}
Modern processors rely on Complimentary Metal Oxide Semiconductor (CMOS) technology.
\autoref{eq:totpwr} separates the power draw of CMOS chips into its component parts, of which dynamic power and leakage power are the most significant.
\begin{equation}
\label{eq:totpwr}
P_{tot} = P_{dyn} + P_{leak} + P_{other}
\end{equation}
Dynamic power is consumed when logic gates change state.
Leakage power exists because at microscopic scales the insulating properties of silicon break down, allowing some current to escape even when gates remain inactive.
Other forms of power dissipation exist, however their effects are relatively minor \cite{kaxiras:2008aa}.
\begin{gather}
P_{dyn} \propto CV^{2}Af \label{eq:dynpwr} \\
P_{leak} = V \times I_{leak} \label{eq:staticpwr}
\end{gather}
\autoref{eq:dynpwr} is a common approximation for dynamic power in which $C$ denotes load capacitance, $V$ the supply voltage, $A$ the activity factor and $f$ the clock frequency.
\autoref{eq:staticpwr} is a simplified expression for leakage power that exploits the fact that leakage current $I_{leak}$ is invariant to processor workload~\cite{kim:2003aa}.

Activity factor captures the fraction of logic elements which change state each clock cycle.
Frequency and supply voltage vary in tandem, taking values from a fixed set of $(frequency, voltage)$ pairs known as P-states.
Dynamic Voltage and Frequency Scaling (DVFS) selects the most appropriate P-state for the current workload.
Finally, capacitance and leakage current are constants dictated by processor design.

Processor architecture also plays a significant roll in determining total power consumption.
Each core in a multicore architecture operates independantly with its own activity factor and in some cases P-state.
As a result, \autoref{eq:totpwr} should be summed across all cores to arrive at a value for the entire processor.

\subsection{Feasible Performance Envelope}
The first step in applying POSE is to construct an appropriate feasible performance envelope.
Manufacturers publish the power dissipation figures of their hardware in the form of a thermal envelope, however these values are usually conservative for safety reasons.
POSE works best when the maximum and minimum power bounds are as tight as possible.
Benchmarks were therefore used to determine $P_{\max}$ and $P_{\min}$ empirically.

We define a benchmark configuration as a tuple $(S,A,C)$ with P-state $S$, activity factor $A$ and $C$ active cores.
Which configuration to use depends on the code and the nature of the optimisations being considered.
POSE models for inherently serial codes should be constructed from benchmark measurements with $C = 1$, for example.
Fortunately, the benchmark configuration space is small enough to measure every point within it in a reasonable amount of time.

The \texttt{cpufrequtils} package allows us to override DVFS and manually set the desired P-state.
We control the number of active cores by specifying the number of threads which should run the benchmarking routine.
Each thread is pinned to its own core to prevent migration.
The only remaining property is activity factor, which is influenced by benchmark code.

\begin{figure}[ht]
\centering
\lstset{basicstyle=\ttfamily\footnotesize\bfseries, frame=tb} %small bold text, lines top and bottom
\lstinputlisting[]{lst/alpha_benchmark.c}
\caption{Activity Factor $\alpha$ Benchmark Code}
\label{fig:microbench}
\end{figure}

We define the range of values that $A$ can take for some fixed $S$ and $C$ as $[\alpha,~\beta]$ where $0 < \alpha < \beta < 1$.
Our code for targeting activity factor $\alpha$ is given in \autoref{fig:microbench}.
It repeatedly executes a single \texttt{jmp} instruction per clock cycle, performing no floating point or integer calculations, no memory accesses and keeping control logic to the bare minimum.

Our measurements in \autoref{tab:code_metrics} support the notion that this code has a lower activity factor than any non-trivial workload.
The only exceptions are applications which block for long periods, allowing the processor to enter an idle state. 
This can be addressed by adding delays to the benchmark if necessary.

We use FIRESTARTER~\cite{hackenberg:2013ab} to reach activity factor $\beta$ and hence measure our value for $P_{max}$.
This tool is designed to trigger near-peak power consumption across a range of x86\_64 processors.
Prime95 and Linpack were also evaluated in this roll, however FIRESTARTER consistently delivered higher power consumption figures.

\begin{table}
\centering
\caption{Feasible Performance Envelope Parameters (W)}
\label{tab:fpe_params}
\input{tab/tex/fpe_params.tex}
\end{table}

We measured the performance of each benchmark for every combination of core count and P-state.
Benchmarks runs lasted for 120 seconds to allow enough time for CPU temperature to stabilize.
The results of this are presented in \autoref{tab:fpe_params}.

\subsection{POSE Models}


\begin{table}
  \setlength{\tabcolsep}{.5em}
  \caption{Code POSE Values}
  \begin{subtable}{\textwidth}
  \centering
  \caption{Time (s)}
  \input{tab/tex/code_pose_time.tex}
  \end{subtable}
  \begin{subtable}{\textwidth}
  \centering
  \caption{Energy (J)}
  \input{tab/tex/code_pose_energy.tex}
  \end{subtable}
  \label{tab:pose_params}
\end{table}



\clearpage

\begin{enumerate}
  \item \todo{Experimental Setup}
  \begin{enumerate}
    \item \todo{Get hardware deets from camelot}
  \end{enumerate}
  \item \todo{Write up results}
  \item \todo{Bosh out freq comparison waffle}
\end{enumerate}


\begin{table}
\centering
\caption{Code Energy Measurements}
\label{tab:code_metrics}
\input{tab/tex/code_metrics.tex}
\end{table}


\begin{figure}[t]%
  \providecommand{\plotwidth}{.95\linewidth}
  \begin{subfigure}[t]{.5\linewidth}%
    \input{plot/minimd-investigation/plot_core}%
    \caption{MiniMD}%
  \end{subfigure}%
  \begin{subfigure}[t]{.5\linewidth}%
    \input{plot/lavamd-investigation/plot_core}%
    \caption{LavaMD}%
  \end{subfigure}%
  \begin{center}%
    \ref{minimd:legend}%
  \end{center}%
  \caption{$E^1t^2$ POSE for Activity Factor Optimisation}%
  \label{fig:minimd}%
\end{figure}

\begin{figure}[t]%
\begin{subfigure}[t]{.5\linewidth}%
\centering%
\input{plot/minimd-pstates/plot_core}%
\caption{MiniMD}%
\end{subfigure}%
\begin{subfigure}[t]{.5\linewidth}%
\input{plot/lavamd-pstates/plot_core}%
\caption{LavaMD}%
\end{subfigure}%
\begin{center}%
\ref{minimd-pstate:legend}%
\end{center}%
\caption{$E^1t^2$ POSE for P-state Optimisation}%
\label{fig:pstates}%
\end{figure}%

Changes in processor P-state do not effect code performance linearly due to system bottlenecks. Critical path? \todo{is there a smart term for this? Bound and bottleneck analysis.} A modern super-scalar CPU contains many specialized functional units. A code which is bottlenecked by Memory accesses may when slowed dow.

A code with low operational intensity

\subsection{Results}

\autoref{tab:pose_params} \todo{reword given central table} shows that for MiniMD, the longest runtime within the Power Optimized Software Envelope is 30.70s.
This means that any optimization which trades increased runtime for improved power efficiency can slow MiniMD down by at most 0.41s before $E^1t^2$ becomes strictly worse.
The upper limit of energy to be saved from power optimisation alone for MiniMD running on our target platform is is 32.82J.
The lowest value of $E^1t^2$ within the envelope is 718232.78, an improvement of 7.60\% over the baseline code.
Runtime optimization will be required to deliver any improvements above this level.
We also know that a speedup of, 1.16x, or 4.16s, is guaranteed to beat $\theta$ in terms of $E^1t^2$.
Finally, a speedup of 1.19x, or 4.84s, is guaranteed to beat any power optimised version of $\theta$ in terms of $E^1t^2$

\autoref{tab:pose_params} \todo{reword given central} shows that for LavaMD, the longest runtime within the Power Optimized Software Envelope as 69.76s.
This means that any optimization which trades increased runtime for improved power efficiency can slow LavaMD down by at most 4.12s before $E^1t^2$ becomes strictly worse.
The upper limit of energy to be saved from power optimization alone is 353.36J.
The lowest value of $E^1t^2$ within the envelope is 6332608.91, an improvement of 30.59\% over the baseline code.
Runtime optimization will be required to deliver any improvements above this level.
We also know that a speedup of 1.11x, or 6.26s, is guaranteed to beat $\theta$ in terms of $E^1t^2$.
Finally, a runtime optimisation of 1.25x, or 13.06s, is guaranteed to beat any power optimised version of $\theta$ in terms of $E^1t^2$

\subsection{Discussion}

\todo{both in absolute terms and as a percentage of the baseline}

The figures produced by POSE are all upper bounds, and the benefits of power optimisation will be more modest in practice. Even so, these figures are useful as they allow performance engineers to make informed decisions about where best to focus their efforts. If they consider a $1.03 \times$ speed up to be more achievable than up to the maximum $1.17\times$ reduction in activity factor then they can proceed to apply conventional optimisations safe in the knowledge that overall performance will improve despite any increases in activity factor.

If a performance engineer decides the benefits of power optimisation are worth pursuing after applying POSE, the question still remains as to how he should go about searching for those optimisations.
