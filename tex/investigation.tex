\section{Investigation}
\label{sec:investigation}
In this section we validate POSE with an investigation into CPU power consumption.
Although we study power consumption at the level of an individual CPU, POSE is platform agnostic and is applicable at any scale.
Our choice of platform was motivated by hardware availability and the relative ease of obtaining accurate figures for CPU power consumption. 
\todo{Some citation re: How big a deal / factor is CPU vs total?}

Applications for this study were selected from the Mantevo~\cite{heroux:2009aa} and Rodinia~\cite{che:2009aa} suites.
Both suites comprise simplified versions of production codes intended for research purposes.
As such they have relatively compact code bases and well understood behaviours whilst still providing representative workloads.

\subsection{CPU Power Consumption}
\begin{equation}
\label{eq:totpwr}
P_{tot} = P_{dyn} + P_{leak} + P_{other}
\end{equation}

Current state-of-the-art processors are based on Complimentary Metal Oxide Semiconductor (CMOS) technology and multi-core superscalar architectures.
\autoref{eq:totpwr} describes how the power draw of CMOS chips can be seperated into components, of which dynamic and leakage power are the most significant.

Dynamic power encompasses the power consumed as logic gates change state while a processor performs work. 
Leakage power stems from the fact that at very small scales the insulating properties of silicon break down, allowing some current to leak out even when gates remain inactive.
Other forms of power dissipation exist, however their effects are relatively minor \cite{kaxiras:2008aa}.

\begin{equation} 
\label{eq:dynpwr}
P_{dyn} \propto CV^{2}Af
\end{equation}

\autoref{eq:dynpwr} is a common approximation for dynamic power in which C denotes load capacitance, $V$ the supply voltage, $A$ the activity factor and $f$ the clock frequency.
Of these, only activity factor is directly related to processor workload as it captures the percentage of logic elements which change state each clock cycle.
Conversely, capacitance is a fixed value arising from the wire lengths of on-chip structures.

Processor frequency and supply voltage may also be influenced by workload through Dynamic Voltage and Frequency Scaling (DVFS).
DVFS varies these properties in tandem, changing between a small number of fixed P-States.
To paraphrase, DVFS acts to reduce the clock speed and voltage of underutilised processors.

Historically, dynamic power has been the biggest contributor to $P_{tot}$, however leakage power has been on track to overtake it since the breakdown of Dennard Scaling.  Sub-threshold and gate-oxide leakage dominate total leakage current, and they both increase exponentially as transistors shrink. Process improvements like the introduction of high-k dielectric materials~\cite{jan:2009aa} have kept leakage power in check over the last decade, however there is no avoiding the fact that insulating properties will degrade as transistors get smaller.

The two factors a performance engineer may influence which contribute to power consumption are activity factor and P-State.
To construct our $P_min$ and $P_max$ we must take into account both of these factors.
We formalise the notion of maximum and minimum power by defining the range of values that activity factor can take whilst running a code in a given P-state as $[\alpha  .. \beta]$ where $0 < \alpha < \beta < 1$, and their associated power draws as $P_{\alpha}$ and $P_{\beta}$ respectively, with $P_{\alpha} < P_{\beta}$.

We employ the code given in \autoref{fig:microbench} to derive our baseline.  It consists of a single instruction, performs no computation and places no demand on the memory subsystems. Any non-trivial computation will have a higher activity factor than this minimal micro-benchmark. If the application to be optimised blocks on IO this can be incorporated by measuring the power consumed when the CPU is inactive and adjusting $P_\alpha$ proportionately. We rely on the \texttt{cpufrequtils} package to override DVFS and manually set the desired P-States.

\subsection{Feasible Performance Envelope}
The first stage in applying POSE is to construct a feasible performance envelope for the target platform.
POSE works best when the maximum and minimum power bounds are as tight as possible.
Processor manufacturers often supply values for the peak and idle power consumption of their hardware, however these estimates tend to be overly conservative and not reachable in practice.
We chose to rely on direct measurements to build our envelope for this reason.



\subsection{Experimental Methodology}
CPU energy consumption was measured using Intel's Running Average Power Limit (RAPL) technology~\cite{david:2010aa}.
We created a simple tool babsed on the Unix \texttt{time} which output energy consumption figures as well as conventional runtime figures.
The techniques described in \cite{hackenberg:2013aa} were used to ensure measurement accuracy. 

\todo{Detail app arguments etc.}

\begin{figure}[ht]                                                               
\centering                                                                      
\lstset{basicstyle=\ttfamily\footnotesize\bfseries, frame=tb} %small bold text, lines top and bottom 
\lstinputlisting[]{lst/alpha_benchmark.c}              
\caption{Baseline Power Micro-Benchmark}                            
\label{fig:microbench}                                                           
\end{figure}  


\todo{consider each in turn as a potential source of optimisations.}
%TODO make sure this is explicitly Linpack table in text
\begin{table}
\centering
\caption{Feasible Performance Envelope Parameters (W) (2 d.p.)}
\input{tab/tex/fpe_params.tex}
\end{table} 

\begin{figure}[t]%
	\providecommand{\plotwidth}{.95\linewidth}
  \begin{subfigure}[t]{.5\linewidth}%
    \input{plot/minimd-investigation/plot_core}%
    \caption{MiniMD}%
  \end{subfigure}%
  \begin{subfigure}[t]{.5\linewidth}%
    \input{plot/lavamd-investigation/plot_core}%
    \caption{LavaMD}%
  \end{subfigure}%
  \begin{center}%
    \ref{minimd:legend}%
  \end{center}%
  \caption{$Et^2$ POSE for Activity Factor Optimisation}%
  \label{fig:minimd}%
\end{figure}

\begin{figure}[t]%
\begin{subfigure}[t]{.5\linewidth}%
\centering%
\input{plot/minimd-pstates/plot_core}%
\caption{MiniMD}%
\end{subfigure}%
\begin{subfigure}[t]{.5\linewidth}%
\input{plot/lavamd-pstates/plot_core}%
\caption{LavaMD}%
\end{subfigure}%
\begin{center}%
\ref{minimd-pstate:legend}%
\end{center}%
\caption{$Et^2$ POSE for P-State Optimisation}%
\label{fig:pstates}%
\end{figure}%

\subsection{Results}

\begin{table}
\centering
\caption{MiniMD POSE, 4 cores at 3.2 GHz (2 d.p.)}
\input{tab/tex/minimd_pose}
\label{tab:minimd_pose}
\end{table} 

\autoref{tab:minimd_pose} shows that for MiniMD, the longest runtime within the Power Optimized Software Envelope is 30.70s.
This means that any optimization which trades increased runtime for improved power efficiency can slow MiniMD down by at most 0.41s before $Et^2$ becomes strictly worse.
The upper limit of energy to be saved from power optimisation alone for MiniMD running on our target platform is is 32.82J.
The lowest value of $Et^2$ within the envelope is 718232.78, an improvement of 7.60\% over the baseline code. 
Runtime optimization will be required to deliver any improvements above this level.
We also know that a speedup of, 1.16x, or 4.16s, is guaranteed to beat $\theta$ in terms of $Et^2$.
Finally, a speedup of 1.19x, or 4.84s, is guaranteed to beat any power optimised version of $\theta$ in terms of $Et^2$

\begin{table}
\centering
\caption{LavaMD POSE, 4 cores at 3.2 GHz (2 d.p.)}
\input{tab/tex/lavamd_pose}
\label{tab:lavamd_pose}
\end{table} 

\autoref{tab:lavamd_pose} shows that for LavaMD, the longest runtime within the Power Optimized Software Envelope as 69.76s.
This means that any optimization which trades increased runtime for improved power efficiency can slow LavaMD down by at most 4.12s before $Et^2$ becomes strictly worse.
The upper limit of energy to be saved from power optimization alone is 353.36J.
The lowest value of $Et^2$ within the envelope is 6332608.91, an improvement of 30.59\% over the baseline code.
Runtime optimization will be required to deliver any improvements above this level.
We also know that a speedup of 1.11x, or 6.26s, is guaranteed to beat $\theta$ in terms of $Et^2$.
Finally, a runtime optimisation of 1.25x, or 13.06s, is guaranteed to beat any power optimised version of $\theta$ in terms of $Et^2$ 

\subsection{Discussion}

\todo{both in absolute terms and as a percentage of the baseline}

The figures produced by POSE are all upper bounds, and the benefits of power optimisation will be more modest in practice. Even so, these figures are useful as they allow performance engineers to make informed decisions about where best to focus their efforts. If they consider a $1.03 \times$ speed up to be more achievable than up to the maximum $1.17\times$ reduction in activity factor then they can proceed to apply conventional optimisations safe in the knowledge that overall performance will improve despite any increases in activity factor.

If a performance engineer decides the benefits of power optimisation are worth pursuing after applying POSE, the question still remains as to how he should go about searching for those optimisations.
