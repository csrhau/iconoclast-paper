\section{Investigation}
\label{sec:investigation}
We now use POSE to investigate the CPU power consumption of codes from the Mantevo~\cite{heroux:2009aa} and Rodinia~\cite{che:2009aa} suites.
The applications we study are simplified versions of production codes intended for research purposes.
As such they exhibit relatively compact code bases and well understood behaviours while still providing represantative workloads.

CPU energy consumption accounts for a significant portion of the energy used by high performance systems~\cite{rong:2010aa} and is therefore a prime target for optimisation.
It can also be measured accurately on comodity hardware~\cite{hackenberg:2013aa} making it a suitable candidate for POSE modelling.

\subsection{CPU Power Consumption}
\label{ssec:cpupower}
Current processors are based on Complimentary Metal Oxide Semiconductor (CMOS) technology.
\autoref{eq:totpwr} separates the power draw of CMOS chips into its component parts, of which dynamic and leakage power are the most significant.
\begin{equation}
\label{eq:totpwr}
P_{tot} = P_{dyn} + P_{leak} + P_{other}
\end{equation}
Dynamic power is consumed when logic gates change state.
Leakage power exists because at microscopic scales the insulating properties of silicon break down, allowing some current to escape even when gates remain inactive.
Other forms of power dissipation exist, however their effects are relatively minor \cite{kaxiras:2008aa}.
\begin{gather}
P_{dyn} \propto CV^{2}Af \label{eq:dynpwr} \\
P_{leak} = V \times I_{leak} \label{eq:staticpwr}
\end{gather}
\autoref{eq:dynpwr} is a common approximation for dynamic power in which $C$ denotes load capacitance, $V$ the supply voltage, $A$ the activity factor and $f$ the clock frequency.
\autoref{eq:staticpwr} is a simplified expression for leakage power which exploits the fact that leakage current $I_{leak}$ is invariant to processor workload~\cite{kim:2003aa}.

Activity factor captures the fraction of logic elements which change state each clock cycle.
Frequency and supply voltage vary in tandem, taking values from a set of $(frequency, voltage)$ pairs known as P-states.
Dynamic Voltage and Frequency Scaling (DVFS) selects a P-state based on workload, or places the CPU into an energy saving mode if no work is available.
Finally, capacitance and leakage current are constants dictated by hardware design.

Processor architecture also plays a significant roll in determining total power consumption.
Each core in a multicore architecture operates independantly with its own activity factor and in some cases P-state.
As a result, \autoref{eq:totpwr} should be summed across all cores to arrive at a value for the entire processor.

\subsection{Feasible Performance Envelope}
The first step in applying POSE is to construct a feasible performance envelope.
Manufacturers publish the power dissipation figures of their hardware, however these values are usually conservative for safety reasons.
POSE works best when the maximum and minimum power bounds are as tight as possible.
We therefore determine $P_{\max}$ and $P_{\min}$ empirically.

We describe power benchmarks using $(S,A,C)$ tuples with P-state $S$, activity factor $A$ and active core count $C$; the three properties which link software to CPU power draw.
Our $P_{min}$ and $P_{max}$ benchmarks should reflect the range of values these properties can take for a given code $\theta$.
We formalise this notion in \autoref{eq:pbench}.
\begin{align}
  \label{eq:pbench}
  \begin{split}
    P_{min} &= (S_{min}, A_{min}, C_{min}~\vert~\theta), \\
    P_{max} &= (S_{max}, A_{max}, C_{max}~\vert~\theta) 
  \end{split}
\end{align}
The values of $S$, $A$, and $C$ depend on the code and the nature of the optimisations being considered.
POSE models for inherently serial codes should be constructed using single threaded benchmarks where $C_{min} = C_{max} = 1$, for example.

The \texttt{cpufrequtils} package allows us to override DVFS and manually set the desired P-state $S$.
We control the number of active cores $C$ by specifying the number of threads used by our benchmarking routines and pinning each one to its own core to prevent migration.
The only remaining property is activity factor, which is influenced by benchmark code.

\begin{figure}[ht]
\centering
\lstset{basicstyle=\ttfamily\footnotesize\bfseries, frame=tb} %small bold text, lines top and bottom
\lstinputlisting[]{lst/alpha_benchmark.c}
\caption{Activity Factor $\alpha$ Benchmark Code}
\label{fig:microbench}
\end{figure}

We define the range of values that $A$ can take for some fixed $S$ and $C$ as $[\alpha,~\beta]$ where $0 < \alpha < \beta < 1$.
Our code for targeting activity factor $\alpha$ is given in \autoref{fig:microbench}.
This benchmark executes a single \texttt{jmp} instruction each clock cycle, preventing instruction pipelining.
It performs no floating point or integer calculations and no memory accesses whilst keeping control logic to a minimum.

Any non-trivial code will perform more work than our benchmark and will therefore have a higher activity factor.
The only exception occurs when applications are blocked for long periods, allowing the processor to enter an idle state.
This can be addressed by adding delays to the benchmark if necessary.

FIRESTARTER~\cite{hackenberg:2013ab} serves as our benchmark for activity factor $\beta$.
This tool is designed to trigger near-peak power consumption across a range of x86\_64 processors.
It consists of hand optimised assembly routines which raise activity factor above the level achievable with high level languages.
Prime95 and Linpack were also evaluated as potential $\beta$ benchmarks however they were consistently outperformed by FIRESTARTER.

The benchmark parameter space is small enough to fully characterise a processor by measuirng all $(S,A,C)$ configurations.
Benchmarking runs lasted for 120 seconds to allow enough time for power readings to stabilize.
We extended the Unix \texttt{time} binary to gather power consumption figures using Intel's Running Average Power Limit (RAPL) technology~\cite{david:2010aa}.
The techniques described in \cite{hahnel:2012aa} were used to promote measurement accuracy.
Results are presented in \autoref{tab:fpe_params}, which identifies P-states by their frequency component.

\begin{table}
\centering
\caption{Feasible Performance Envelope Parameters (W)}
\label{tab:fpe_params}
\input{tab/tex/fpe_params.tex}
\end{table}

\subsection{POSE Models for Code Optimisation}
Having characterised our system we now proceed to build POSE models for applications in the Mantevo and Rodinia suites.
These codes were compiled with ICC version 14.0.0.
Codes were run with default configurations where available.
The energy and runtime costs associated with each code is given in \autoref{tab:code_metrics}.

\begin{table}
\centering
\caption{Code Energy Measurements}
\label{tab:code_metrics}
\input{tab/tex/code_metrics.tex}
\end{table}

All codes evaluated ran in parallel across four cores.
They also spent a negligible amount of time waiting for resources. 
This allowed the CPU to run at its maximum supported frequency of 3.2 GHz.
For the first stage of this investigation we disregard any optimisations which reduce parallelism ($C < 4$) or reduce processor throughput ($S < 3.2GHz$).
The benchmark configurations used were $(\text{3.2 GHz}, \alpha, 4)$ for $P_{min}$ and $(\text{3.2 GHz}, \beta, 4)$ for $P_{max}$, yielding power draws of 26.88W and 49.61W respectively.

\begin{table}
  \setlength{\tabcolsep}{.5em}
  \caption{$E^1t^2$ POSE Points}
  \begin{subtable}{\textwidth}
  \centering
  \caption{Time (s)}
  \input{tab/tex/code_pose_time.tex}
  \end{subtable}
  \begin{subtable}{\textwidth}
  \centering
  \caption{Energy (J)}
  \input{tab/tex/code_pose_energy.tex}
  \end{subtable}
  \label{tab:pose_params}
\end{table}

\autoref{tab:pose_params} summarises the POSE models constructed for each code.
The remainder of this section focusses on MiniMD and LavaMD as the two codes which represent the extremes of power consumption.
POSE models for these two codes are reproduced graphically in \autoref{fig:minimd_pose} and \autoref{fig:lavamd_pose}.
When comparing these diagrams it is readily apparent that LavaMD offers far more scope for power optimisation than MiniMD, which offers virtually none. 
POSE provides the following insights for LavaMD:
\begin{itemize}
  \item At most 353.36J can be saved by reducing power consumption
  \item The maximum slowdown from energy optimisation is 4.12s
  \item The lowest $E^1t^2$ value from power optimisation is 6332609
  \begin{itemize}
  \item Corresponding to a 30.59\% improvement
  \end{itemize}
  \item A speedup of 8.77s, or 1.15x, strictly outperforms $\theta$
  \item A speedup of 15.29s, or 1.30x, strictly outperforms any power optimisation
\end{itemize}

\begin{figure}[t]%
  \providecommand{\plotwidth}{.95\linewidth}
  \begin{subfigure}[t]{.5\linewidth}%
    \input{plot/minimd-investigation/plot_core}%
    \caption{MiniMD}%
    \label{fig:minimd_pose}
  \end{subfigure}%
  \begin{subfigure}[t]{.5\linewidth}%
    \input{plot/lavamd-investigation/plot_core}%
    \caption{LavaMD}%
    \label{fig:lavamd_pose}
  \end{subfigure}%
  \begin{center}%
    \ref{minimd:legend}%
  \end{center}%
  \caption{$E^1t^2$ POSE comparrison}%
  \label{fig:comparrison}%
\end{figure}

\begin{figure}[t]%
\begin{subfigure}[t]{.5\linewidth}%
\centering%
\input{plot/minimd-pstates/plot_core}%
\caption{MiniMD}%
\end{subfigure}%
\begin{subfigure}[t]{.5\linewidth}%
\input{plot/lavamd-pstates/plot_core}%
\caption{LavaMD}%
\end{subfigure}%
\begin{center}%
\ref{minimd-pstate:legend}%
\end{center}%
\caption{$E^1t^2$ POSE for P-state Optimisation}%
\label{fig:pstates}%
\end{figure}%


\subsection{POSE Models for Frequency Scaling}
DVFS impacts performance in a non-linear fashion. \todo{cite critical power slope}
Codes prone to external bottlenecks like memory bandwidth or I/O latency typically leave the CPU underutilized.
In these cases reducing the clock frequency can deliver energy savings without significant performance degradation. \todo{cite 




Research has shown that in these cases energy can be saved with 

be made 

http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.60.8266&rep=rep1&type=pdf

In these cases



DVFS attempts to select the most appropriate P-state for the current workflow.
That said, its reactive and coarse grained nature mean that its decisions can be sub-optimal decisions.
Optimal frequency schedule, so that the processor only works as fast as 

In this case CPU frequency can be reduced without adversely affecting performance.
Conversely, if the CPU itself is a performance bottleneck, the maximum frequency possible should be selected.



e the balance of pressures on external bottlenecks.


If instruction throughput is a limiting factor then reducing clock frequency will adversely affect performance.


If a CPU is often idle because of external bottlenecks
like memory bandwidth then reducing its 


This is most obvious when factors





When the limiting factor is external to the CPU then reducing the clock frequency may not adversely impact performance.



Code performance is not linear in terms of rocessor P-state do not linffect code performance linearly, and as such.

In the presence of optimisation..

The flexibility of POSE allows it to evaluate the potential for optimisations at different P-states.
We can use POSE to evaluate these

Critical path? \todo{is there a smart term for this? Bound and bottleneck analysis.} A modern super-scalar CPU contains many specialized functional units. A code which is bottlenecked by Memory accesses may when slowed dow.

A code with low operational intensity

\subsection{Discussion}

\todo{The graphs and tables of results within this section were produced automatically.}

The figures produced by POSE are all upper bounds, and the benefits of power optimisation will be more modest in practice. Even so, these figures are useful as they allow performance engineers to make informed decisions about where best to focus their efforts. If they consider a $1.03 \times$ speed up to be more achievable than up to the maximum $1.17\times$ reduction in activity factor then they can proceed to apply conventional optimisations safe in the knowledge that overall performance will improve despite any increases in activity factor.

If a performance engineer decides the benefits of power optimisation are worth pursuing after applying POSE, the question still remains as to how he should go about searching for those optimisations.
