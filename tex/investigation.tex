\section{Investigation}
\label{sec:investigation}
We now use POSE to investigate the CPU power consumption of various codes from the Mantevo~\cite{heroux:2009aa} and Rodinia~\cite{che:2009aa} application suites.
Both contain simplified versions of production codes intended for research purposes.
As such these codes have relatively compact code bases and well understood behaviours whilst still providing representative workloads.

CPU power consumption accounts for a significant portion of energy used by high performance systems~\cite{rong:2010aa}, making it a prime candidate for optimisation.
Crucially for POSE, this level of power consumption can be measured on hardware available to us using techniques the described in ~\cite{hackenberg:2013aa}.

%CPU Power Consumption
\subsection{CPU Power Consumption}
Current state-of-the-art processors are based on Complimentary Metal Oxide Semiconductor (CMOS) technology.
\autoref{eq:totpwr} describes how the power draw of CMOS chips can be separated into components, of which dynamic and leakage power are the most significant.


\begin{equation}
\label{eq:totpwr}
P_{tot} = P_{dyn} + P_{leak} + P_{other}
\end{equation}


Dynamic power is consumed by logic gates changing state whilst a processor performs work. 
Leakage power stems from the fact that at microscopic scales the insulating properties of silicon break down, allowing some current to leak out even when gates remain inactive.
Other forms of power dissipation exist, however their effects are relatively minor \cite{kaxiras:2008aa}.

\begin{gather}
P_{dyn} \propto CV^{2}Af \label{eq:dynpwr} \\
P_{leak} = V \times I_{leak} \label{eq:staticpwr} \\
P_{tot} \propto CV^{2}Af + VI_{leak} \label{eq:totpwr2}
\end{gather}


\autoref{eq:dynpwr} is a common approximation for dynamic power in which C denotes load capacitance, $V$ the supply voltage, $A$ the activity factor and $f$ the clock frequency. \autoref{eq:staticpwr} is a simplified expression for leakage power that exploits the fact that leakage current $I_{leak}$ is invariant to processor workload~\cite{kim:2003aa}. Substituting these into \autoref{eq:totpwr} yields the parametrised expression for total power consumption in \autoref{eq:totpwr2}.

Of the parameters in \autoref{eq:totpwr2}, only activity factor is directly related to processor workload as it captures the percentage of logic elements which change state each clock cycle.
 Processor workload can also influence frequency and supply voltage indirectly through the actions of Dynamic Voltage and Frequency Scaling (DVFS). 
DVFS varies these properties in tandem, choosing pairs of values from a small number of fixed P-States.
Finally, capacitance and leakage current are constants  dictated by processor design.

\subsection{Feasible Performance Envelope}
The first step in applying POSE is the construction of an appropriate feasible performance envelope.
Processor manufacturers often supply values for the peak and idle power consumption of their hardware, however these tend to be conservative estimates which cannot be reached in practice. 
POSE works best when the maximum and minimum power bounds are as tight as possible.
For this reason we 


There are two factors a software developer may influence which can effect CPU power consumption, namely activity factor and P-state.

\todo{WORKING POINT}

Linpack is characterised by its extremely high code intensity. 
\todo{false baselines etc}
This highlights the fact that effective use of POSE depends largely on the choice of roofline and 

Historically, dynamic power has been the biggest contributor to $P_{tot}$, however leakage power has been on track to overtake it since the breakdown of Dennard Scaling.  Sub-threshold and gate-oxide leakage dominate total leakage current, and they both increase exponentially as transistors shrink. Process improvements like the introduction of high-k dielectric materials~\cite{jan:2009aa} have kept leakage power in check over the last decade, however there is no avoiding the fact that insulating properties will degrade as transistors get smaller.

The two factors a performance engineer may influence which contribute to power consumption are activity factor and P-State.
To construct our $P_min$ and $P_max$ we must take into account both of these factors.
We formalise the notion of maximum and minimum power by defining the range of values that activity factor can take whilst running a code in a given P-state as $[\alpha  .. \beta]$ where $0 < \alpha < \beta < 1$, and their associated power draws as $P_{\alpha}$ and $P_{\beta}$ respectively, with $P_{\alpha} < P_{\beta}$.

We employ the code given in \autoref{fig:microbench} to derive our baseline.  It consists of a single instruction, performs no computation and places no demand on the memory subsystems. Any non-trivial computation will have a higher activity factor than this minimal micro-benchmark. If the application to be optimised blocks on IO this can be incorporated by measuring the power consumed when the CPU is inactive and adjusting $P_\alpha$ proportionately. We rely on the \texttt{cpufrequtils} package to override DVFS and manually set the desired P-States.

\subsection{Feasible Performance Envelope}

We chose to rely on direct measurements to build our envelope for this reason.


\begin{table}
\centering
\caption{Early Investigation}
\input{tab/tex/code_metrics.tex}
\end{table} 



  \begin{table}
    \setlength{\tabcolsep}{.5em}
    \caption{Code POSE Values}
    \begin{subtable}{\textwidth}
    \centering
    \caption{Time (s)}
    \input{tab/tex/code_pose_time.tex}
    \end{subtable} 
    \begin{subtable}{\textwidth}
    \centering
    \caption{Energy (J)}
    \input{tab/tex/code_pose_energy.tex}
    \end{subtable}
    \label{tab:pose_params}
  \end{table} 



\subsection{Experimental Methodology}
CPU energy consumption was measured using Intel's Running Average Power Limit (RAPL) technology~\cite{david:2010aa}.
We created a simple tool babsed on the Unix \texttt{time} which output energy consumption figures as well as conventional runtime figures.
The techniques described in \cite{hahnel:2012aa} were used to ensure measurement accuracy. 

\todo{Detail app arguments etc.}

\begin{figure}[ht]                                                               
\centering                                                                      
\lstset{basicstyle=\ttfamily\footnotesize\bfseries, frame=tb} %small bold text, lines top and bottom 
\lstinputlisting[]{lst/alpha_benchmark.c}              
\caption{Baseline Power Micro-Benchmark}                            
\label{fig:microbench}                                                           
\end{figure}  


\todo{consider each in turn as a potential source of optimisations.}
%TODO make sure this is explicitly Linpack table in text
\begin{table}
\centering
\caption{Feasible Performance Envelope Parameters (W)}
\input{tab/tex/fpe_params.tex}
\end{table} 

\begin{figure}[t]%
	\providecommand{\plotwidth}{.95\linewidth}
  \begin{subfigure}[t]{.5\linewidth}%
    \input{plot/minimd-investigation/plot_core}%
    \caption{MiniMD}%
  \end{subfigure}%
  \begin{subfigure}[t]{.5\linewidth}%
    \input{plot/lavamd-investigation/plot_core}%
    \caption{LavaMD}%
  \end{subfigure}%
  \begin{center}%
    \ref{minimd:legend}%
  \end{center}%
  \caption{$E^1t^2$ POSE for Activity Factor Optimisation}%
  \label{fig:minimd}%
\end{figure}

\begin{figure}[t]%
\begin{subfigure}[t]{.5\linewidth}%
\centering%
\input{plot/minimd-pstates/plot_core}%
\caption{MiniMD}%
\end{subfigure}%
\begin{subfigure}[t]{.5\linewidth}%
\input{plot/lavamd-pstates/plot_core}%
\caption{LavaMD}%
\end{subfigure}%
\begin{center}%
\ref{minimd-pstate:legend}%
\end{center}%
\caption{$E^1t^2$ POSE for P-State Optimisation}%
\label{fig:pstates}%
\end{figure}%

Changes in processor P-State do not effect code performance linearly due to system bottlenecks. Critical path? \todo{is there a smart term for this? Bound and bottleneck analysis.} A modern super-scalar CPU contains many specialized functional units. A code which is bottlenecked by Memory accesses may when slowed dow.

A code with low operational intensity 


\subsection{Results}


\autoref{tab:pose_params} \todo{reword given central table} shows that for MiniMD, the longest runtime within the Power Optimized Software Envelope is 30.70s.
This means that any optimization which trades increased runtime for improved power efficiency can slow MiniMD down by at most 0.41s before $E^1t^2$ becomes strictly worse.
The upper limit of energy to be saved from power optimisation alone for MiniMD running on our target platform is is 32.82J.
The lowest value of $E^1t^2$ within the envelope is 718232.78, an improvement of 7.60\% over the baseline code. 
Runtime optimization will be required to deliver any improvements above this level.
We also know that a speedup of, 1.16x, or 4.16s, is guaranteed to beat $\theta$ in terms of $E^1t^2$.
Finally, a speedup of 1.19x, or 4.84s, is guaranteed to beat any power optimised version of $\theta$ in terms of $E^1t^2$

\autoref{tab:pose_params} \todo{reword given central} shows that for LavaMD, the longest runtime within the Power Optimized Software Envelope as 69.76s.
This means that any optimization which trades increased runtime for improved power efficiency can slow LavaMD down by at most 4.12s before $E^1t^2$ becomes strictly worse.
The upper limit of energy to be saved from power optimization alone is 353.36J.
The lowest value of $E^1t^2$ within the envelope is 6332608.91, an improvement of 30.59\% over the baseline code.
Runtime optimization will be required to deliver any improvements above this level.
We also know that a speedup of 1.11x, or 6.26s, is guaranteed to beat $\theta$ in terms of $E^1t^2$.
Finally, a runtime optimisation of 1.25x, or 13.06s, is guaranteed to beat any power optimised version of $\theta$ in terms of $E^1t^2$ 



\todo{cf DVFS: This highlights the fact that POSE models from different codes or in this case configurations can be directly compared}

\subsection{Discussion}

\todo{both in absolute terms and as a percentage of the baseline}

The figures produced by POSE are all upper bounds, and the benefits of power optimisation will be more modest in practice. Even so, these figures are useful as they allow performance engineers to make informed decisions about where best to focus their efforts. If they consider a $1.03 \times$ speed up to be more achievable than up to the maximum $1.17\times$ reduction in activity factor then they can proceed to apply conventional optimisations safe in the knowledge that overall performance will improve despite any increases in activity factor.

If a performance engineer decides the benefits of power optimisation are worth pursuing after applying POSE, the question still remains as to how he should go about searching for those optimisations.
