\section{Approaches to Modelling}
\label{sec:approaches}
Performance modelling techniques enable the rapid exploration of large hardware and software design spaces.
In this section we describe various approaches to performance modelling and show where POSE fits into this picture.
\autoref{tab:approaches} divides the performance modelling ecosystem into categories based on model domain and granularity and provides examples for each.

\begin{table}
  \centering
  \caption{Performance Model Classifications}
  \setlength{\tabcolsep}{10pt}
  \begin{tabular}{lll}
  \toprule
    & \multicolumn{2}{l}{Domain}\\ \cmidrule(){2-3}
  Model Type  & Runtime & Energy \\
    \midrule
  Simulation & SST~\cite{rodrigues:2011aa} & McPAT~\cite{li:2009aa}  \\
  Analytical & Bunt~\cite{bunt:2013aa} & Karkhanis~\cite{karkhanis:2007aa} \\
  Heuristic & Roofline~\cite{williams:2009aa} & \textbf{This Work} \\
  \bottomrule
  \end{tabular}
  \label{tab:approaches}
\end{table}

\subsubsection{Simulators:} 
Tools like SST~\cite{rodrigues:2011aa} and McPAT~\cite{li:2009aa} execute a simplified representation of the original code whilst gathering data.
These approaches can be extremely insightful, however constructing and validating representative simulations is often challenging.
They also tend to be expensive to run, sometimes even more so than the original code.

\subsubsection{Analytical Models:} This approach distils the structure and performance of a program into a parameterised expression.
Examples of this technique are found in the work of Bunt~et~al.~\cite{bunt:2013aa} and Karkhanis~et~al.~\cite{karkhanis:2007aa}.
These models run much faster than simulations, making them particularly useful when performing parameter sweeps.
Ensuring the model is expressive enough to capture all possible program behaviours is the biggest obstacle to this approach as it requires a deep understanding of the target application.

\subsubsection{Heuristic Models:}
This is the most abstract category of performance models and the one in which our work belongs.
Rather than attempting to faithfully represent an entire system, heuristic models provide a simplified analogy which helps developers to reason about particular properties of a code.
These models are easy to construct and see most use in the early, exploratory stages of code optimisation. 

A popular example from this class is the Roofline~\cite{williams:2009aa} model.
Roofline frames the performance of an application in terms of its operational intensity and two system bottlenecks; off-chip memory bandwidth and floating point performance.
This simplification limits Roofline's use as a predictive model but it also means a developer can easily identify the factor limiting the performance of their code and target their efforts accordingly.
Developer time is a finite and valuable resource, and as such there is considerable merit to the kind of easy to understand and actionable insights offered by heuristic models.

The POSE heuristic serves as a preliminary `first cut' modelling technique intended to guide energy-aware optimisation efforts.
Our model provides an asymptotic analysis of the scope for optimisation in the power and runtime domains, allowing performance engineers to focus their efforts where they will be most beneficial.
POSE takes after the Roofline model in that they both express their insights in the form of a two-dimensional graphical representation.
