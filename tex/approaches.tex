\section{Approaches to Modelling}
\label{sec:approaches}
Performance modelling techniques enable the rapid exploration of large hardware and software design spaces.
In this section we present a breakdown of modelling approaches and show where our technique fits in.
\autoref{tab:approaches} divides the performance modelling ecosystem into categories based on model domain and granularity and provides examples for each.

\begin{table}
  \centering
  \caption{Performance Model Classifications}
  \setlength{\tabcolsep}{10pt}
  \begin{tabular}{lll}
  \toprule
    & \multicolumn{2}{l}{Domain}\\ \cmidrule(){2-3}
  Model Type  & Runtime & Energy \\
    \midrule
  Simulation & SST~\cite{rodrigues:2011aa} & McPAT~\cite{li:2009aa}  \\
  Analytical & Bunt~\cite{bunt:2013aa} & Karkhanis~\cite{karkhanis:2007aa} \\
  Heuristic & Roofline~\cite{williams:2009aa} & \textbf{This Work} \\
  \bottomrule
  \end{tabular}
  \label{tab:approaches}
\end{table}

\subsubsection{Simulators:} 
Tools like SST~\cite{rodrigues:2011aa} and McPAT~\cite{li:2009aa} execute a simplified representation of the original code whilst gathering data.
These approaches can be extremely insightful, however constructing and validating representative simulations is often challenging.
They also tend to be expensive to run, sometimes even more so than the original code.

\subsubsection{Analytical Models:} This approach attempts to distil the structure and performance of a program into a parameterised expression.
Examples of this technique can be found in the work of Bunt~et~al.~\cite{bunt:2013aa} and Karkhanis~et~al.~\cite{karkhanis:2007aa}.
These models run much faster than simulations, making them particularly useful when performing parameter sweeps or answering speculative questions.
Constructing an analytical model requires a thorough understanding of the target application to ensure the model expressive enough to capture all possible program behaviours.

\subsubsection{Heuristic Models:}
This is the most abstract approach to performance modelling and the one to which our work belongs.
Rather than attempting to faithfully represent an entire system, heuristic models provide a simplified analogy which helps developers to reason about particular properties of a code.
Typically these models are easy to construct and see most use in the early, exploratory stages of code optimisation. 

A popular example of this class is the Roofline~\cite{williams:2009aa} model.
Roofline frames the performance of an application in terms of its operational intensity and two system bottlenecks; off-chip memory bandwidth and floating point performance.
This simplification limits Roofline's use as a predictive model but it also means a developer can easily understand the limiting factor for the performance of their code and target their efforts accordingly.
Developer time is a finite and valuable resource, and as such there is considerable merit to the kind of easy to understand and actionable insights offered by heuristic models.

The POSE heuristic serves as a preliminary `first cut' modelling technique intended to guide energy-aware optimisation efforts.
Our model takes after the Roofline model in that they both express their insights in the form of a two-dimensional graphical representation.
POSE provides an asymptotic analysis of the scope for optimisation in the power and runtime domains, allowing performance engineers to focus their efforts where they will be most beneficial.
