\section{Approaches to Modelling}
\label{sec:approaches}
Performance modelling techniques enable the rapid exploration of large hardware and software design spaces.
They allow engineers to reason about the performance of their code without the need to aquire measurements for all possible optimisations and configurations.
In this section we present a breakdown of modelling approaches and show where our technique fits in.

\begin{table}
  \centering
  \caption{Performance Model Classifications}
  \setlength{\tabcolsep}{10pt}
  \begin{tabular}{lll}
  \toprule
    & \multicolumn{2}{l}{Domain}\\ \cmidrule(){2-3}
  Model Type  & Runtime & Energy \\
    \midrule
  Simulation & SST~\cite{rodrigues:2011aa} & McPAT~\cite{li:2009aa}  \\
  Analytical & Bunt~\cite{bunt:2013aa} & Karkhanis~\cite{karkhanis:2007aa} \\
  Heuristic & Roofline~\cite{williams:2009aa} & \textbf{This Work} \\
  \bottomrule
  \end{tabular}
  \label{tab:approaches}
\end{table}

\autoref{tab:approaches} divides the performance modelling ecosystem into categories based on model domain and granularity.
We now describe these categories and provide examples for each.

\subsubsection{Simulators:} 
Tools like SST~\cite{rodrigues:2011aa} and McPAT~\cite{li:2009aa} execute a simplified representation of the original code whilst gathering data.
These approaches are often extremely insightful, however constructing and validating representative simulations can be challenging.
They also tend to be expensive to run, sometimes even more so than the original code.

\subsubsection{Analytical Models:} This approach attempts to distil the structure and performance of a program into a parameterised expression.
Examples of this technique can be found in the work of Bunt~et~al.~\cite{bunt:2013aa} and Karkhanis~et~al.~\cite{karkhanis:2007aa}.
These models run much faster than simulations, making them particularly useful when performing parameter sweeps or answering speculative questions.
Constructing an analytical model requires a thorough understanding of the target application to ensure the model expressive enough to capture all possible program behaviours.

\subsubsection{Heuristic Models:}
This is the most abstract approach to performance modelling and the one to which our work belongs.
Rather than attempting to faithfully represent a system, heuristic models provide a simplified analogy which helps developers to reason about particular properties of a code.
A good example of this is the Roofline model~\cite{williams:2009aa}, which reduces system performance to two bottlenecks; off-chip memory bandwidth and floating point performance; and the operational intensity of a code.

The POSE heuristic serves as a preliminary `first cut' modelling technique intended to guide energy-aware optimisation efforts.
It provides an asymptotic analysis of the scope for optimisation in the power or time domain.
This allows developers to focus their efforts where they will be most beneficial.

POSE takes after the Roofline model in that they both express their insights in the form of a two-dimensional graphical representation.
Developer time is a finite and valuable resource, and there is considerable merit to these easy to understand and intuitive presentations of meaningful insights.
Like Roofline, The POSE heuristic is intended for use in the early stages of an optimisation attempt preliminary 


