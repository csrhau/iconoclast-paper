\section{metrics}

Any attempt to optimize a code must be based on a suitable metric.
This is necessary both to help identify areas of improvement as well as to derive the utility of potential changes.
Before we introduce our heuristic to guide optimization, we must first consider the metrics which we may wish to optimize. 

The choice of metric is often domain dependent and must capture the practical requirements of a system.
This is why runtime has been the predominant metric in performance critical domains whilst energy has been largely confined to embedded systems.
That said, metrics which capture the importance of power as well as time are becoming more prominent in high performance computing as the power needs of modern systems continue to rise.

Power consumption is an intuitive choice of metric as it captures the rate at which a given code consumes energy. It also has the benefit of being relatively easy to measure at scale. As \autoref{fig:motivation} shows, however, power alone is not an appropriate metric for this domain. Paradoxically, optimizations to reduce power draw can lead to increases in runtime and in turn greater total energy consumption. For an unoptimized code $\theta$, the rightmost shaded sector of this plot corresponds to feasible  

Energy to completion is often chosen when energy consumption is of critical importance. It is often used in domains like mobile robotics where available energy is severely restricted. That said, in most domains energy is not the only limiting factor. In practice the most useful metrics are those which combine the effects of both energy and runtime. The simplest of these is the energy-delay product (EDP) \cite{gonzales:1995aa}, which assigns an equal weighting to both runtime and energy consumption and is defined as follows:
\begin{align}
  EDP = Energy \times Runtime \nonumber \\
      \Leftrightarrow Power \times Runtime^{2} 
  \label{eq:edp}
\end{align}

Several extensions to EDP have been proposed which assign greater weight to the runtime component in accordance with the demands of high performance computing. Common examples include energy-delay-squared product ($ED^{2}P$) and energy-delay-cubed product ($ED^{3}P$). We refer to this as the $E^mD^n$ family of metrics, which also includes simple power ($E^1D^{-1}$), energy ($E^1D^0$) and time ($E^0D^1$) as members. It can be argued that that $ED^{2}P$ is most suited when considering a fixed micro-architecture \cite{brooks:2000aa}, however our work applies to all members of this group with $m > 0$ and $n \geq 0$.
