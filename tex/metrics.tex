\section{metrics}
\label{sec:metrics}
Historically, runtime has been the predominant metric used in performance critical domains whilst energy has largely been confined to embedded systems.
That said, metrics which capture the importance of power as well as time are gaining prominence as the power requirements of scientific computing continue to rise.

\autoref{fig:motivation} introduces the concept of a \emph{Feasible Performance Envelope} in support of our discussion.
These constructs represent the set of all $\langle Runtime, Energy\rangle$ costs it is possible for an arbitrary code to exhibit when running on a target platform.
We cover the construction of this envelope in more detail in \autoref{sec:pose}.
For now, we simply state that any optimized or otherwise altered versions of a given code $\theta$ must also exist within this space.

\begin{figure}
\centering
\input{plot/motivation/plot_core}
\caption{Feasible Performance Envelope}
\label{fig:motivation}
\end{figure}

Power consumption is a seemingly obvious choice of metric in energy sensitive domains as it captures the rate at which energy is consumed.
The ability to detect power hungry sections of code would clearly help identify candidates for optimization.
That said, power is rarely an appropriate metric to optimize for.
Optimizations to reduce power draw can in principle lead to increases in runtime and in turn greater total energy consumption.
The upper right shaded sector of \autoref{fig:motivation} corresponds to this case.

Energy to completion is a reasonable metric when energy consumption is of paramount importance.
It is often used in domains like mobile robotics and sensor where available energy is severely restricted.
That said, whilst energy is becoming more important in domains like scientific computing, it is not the only limiting factor. 
Reliance on energy as a metric leaves open the possibility of unacceptable loss of runtime performance.

In practice the most useful metrics are those which combine both energy and runtime.
The simplest of these is the Energy-Delay product (EDP) metric \cite{gonzales:1995aa}, which assigns an equal weighting to both runtime and energy consumption and is defined as follows:
\begin{align}
  EDP = Energy \times Runtime \nonumber \\
      \Leftrightarrow Power \times Runtime^{2} 
  \label{eq:edp}
\end{align}

Several extensions to EDP have been proposed which assign greater weight to the runtime component in accordance with the demands of high performance computing. Common examples include energy-delay-squared product ($ED^{2}P$) and energy-delay-cubed product ($ED^{3}P$). We refer to this as the $E^mD^n$ family of metrics, which also includes simple power ($E^1D^{-1}$), energy ($E^1D^0$) and time ($E^0D^1$) as members. It can be argued that that $ED^{2}P$ is most suited when considering a fixed micro-architecture \cite{brooks:2000aa}, however our work applies to all members of this group with $m > 0$ and $n \geq 0$.
