\section{Power Optimized Software Envelope}
\label{sec:pose}

POSE operates by...\todo{intro}

\begin{figure}
\centering
\input{plot/technique/plot_core}
\caption{$Et^2$ Power Optimized Software Envelope}
\label{fig:technique}
\end{figure}

\subsection{Feasible Performance Envelope}
The POSE heuristic is based around the concept of a \emph{Feasible Performance Envelope}.
We construct this by plotting lines of gradient $P_{max}$ and $P_{min}$ in \autoref{fig:technique}.
These values represent the maximum and minimum rate of power consumption which can occur during normal operation of the target platform.
By definition the $\langle Runtime, Energy\rangle$ costs incurred by running any given code $\theta$ on the target platform must be represented somewhere within this envelope.

\subsection{Optimization Bound}
To constrain our search space further we now consider the metric we wish to reduce.
For two logically equivalent codes $\theta$ and $\lambda$, the transformation ${\theta \to \lambda}$ is a valid optimization with respect to a cost metric $M$ if and only if ${M(\lambda) < M(\theta)}$.
If we plot a curve passing through $\theta$ linking all points with ${M(\lambda) = M(\theta)}$, then by definition any optimized versions of $\theta$ can only exist below this optimization bound.

Naturally the equation for the optimization bound depends on the metric we are optimizing for.
\autoref{fig:technique} shows the optimization bound for $Et^2$.
The general form of this bound for the $E^mt^n$ family of metrics is derived as follows:
\begin{align}
E^mt^n(\lambda) &= E^mt^n(\theta) \nonumber \\
\implies {E_\lambda}^m &= \frac{{E_\theta}^m{t_\theta}^n}{{t_\lambda}^n} \nonumber \\
\implies E_\lambda &= (\frac{{E_\theta}^m{t_\theta}^n}{{t_\lambda}^n})^\frac{1}{m}
\label{eq:optimization}
\end{align}

\subsection{Contribution Bound}
Our second bound considers what it means to optimize code for reduced power draw. 
We define optimization $\theta \to \lambda$ with respect to metric $M$ to be a power optimization if the change in power draw it delivers is responsible for the majority of the reduction in $M$. We plot a curve through $\theta$ linking all points with the same ratio of contributions to $M$ from both power and runtime factors as our original code. All valid power optimizations must lie below this contribution bound. 

Again the equation for the contribution bound depends on the metric chosen. 
\autoref{fig:technique} shows the bound for $Et^2$ whilst the general form for $E^mt^n$ metrics is:
\begin{align}
\frac{{P_{\lambda}}^m}{{t_{\lambda}}^{m+n}} &= \frac{{P_{\theta}}^m}{{t_{\theta}}^{m+n}} \nonumber \\
\implies {P_{\lambda}}^m &= \frac{{P_{\theta}}^m}{{t_{\theta}}^{m+n}} \times {t_\lambda}^{m+n} \nonumber \\ 
\implies {E_{\lambda}}^m &= \frac{{P_{\theta}}^m}{{t_{\theta}}^{m+n}} \times {t_\lambda}^{m+n+1} \nonumber \\ 
\implies E_{\lambda} &= (\frac{{P_{\theta}}^m}{{t_{\theta}}^{m+n}} \times {t_\lambda}^{m+n+1})^{\frac{1}{m}} 
\end{align}

Intuitively it makes sense to use the most appropriate tools while searching for optimizations.  If an optimization yields dramatic reductions in runtime with only minor reductions in power consumption then it is reasonable to classify it as a runtime optimization and state that conventional time-based profilers and performance engineering tools are better suited to finding it. It is the contribution bound which enables our model to make this distinction.
\subsection{Optimization Limit}
The bounds described thus far allow us to identify the area of the Energy/Runtime plane in which optimized versions of a given code may exist and to subdivide this space into runtime and power optimizations. The final component of POSE is the Optimization Limit, which subdivides the runtime optimized area of the feasible performance envelope into those optimizations which may be outperformed by power optimizations, and those which strictly dominate all possible power optimizations.

The dashed Optimization Limit is based on \autoref{eq:optimization} and closely mirrors the the optimization bound.
This limit connects all points with the same value for $M$ as a hypothetical maximally power optimized version of $\theta$. 
All points below this limit have lower values for $M$, and therefore any optimizations in this area strictly dominate any possible power optimizations. 


\section{POSE Insights}
\label{sec:insights}
The POSE Model partitions the feasible performance envelope from \autoref{fig:technique} into several areas.
These areas allow us to classify possible optimizations according to which of the following labelled areas they fall in:

\begin{enumerate}
\item Strong Runtime Optimization
\item Weak Runtime Optimization
\item Partial Power Optimization
\item Pure Power Optimization
\item Performance Degradation
\end{enumerate}

The Strong Runtime Optimization area \textbf{1} encompasses all points with a better $M$ score than the best case power optimization for $\theta$. The Weak Runtime Optimization area \textbf{2} encompasses all possible runtime optimizations which have a better performance than $\theta$ in terms of $M$ yet may in turn be beaten by some power optimized version of $\theta$. The Partial \textbf{3} and Pure \textbf{4} power optimization spaces correspond to optimized versionso of $\theta$ for which reductions in $M$ are due primarily or entirely to reductions in power consumption.
Finally, Performance Degradation \textbf{5} corresponds to all codes with strictly worse performance than $\theta$.


POSE offers a wealth of information to performance engineers.
The difference in energy between $\theta$ and intercept $D$ places an upper limit on the amount of energy which can be saved by power optimization alone.
The value $M(\theta) - M(C)$ bounds the amount of improvement in our metric we can expect to see from power optimization.
The difference in runtime between intersect $E$ and $\theta$ represents the maximum increase in runtime we could feasibly trade off to achieve a slower yet more energy efficient code.
Finally, the values $t_\theta / t_B$ represents the smallest speed-up which would guarantee a code which outperformed $\theta$, and $t_\theta / t_A$ the smallest speed-up guaranteed to outperform any power optimized version of $\theta$.

It is worth restating at this point that POSE is a metric-agnostic heuristic. \autoref{fig:multimetric-technique} shows how the POSE heuristic varies with choice of metric using $E^1t^0$ and $E^1t^2$ as examples. POSE offers the insights discussed above regardless of the metric chosen.

\begin{figure}
\centering
\input{plot/multimetric-technique/plot_core}
\caption{POSE for Different Metrics}
\label{fig:multimetric-technique}
\end{figure}
